{
  "files": {
    "vercel.json": {
      "rewrites": [
        {
          "source": "/api/upload-metadata",
          "destination": "/api/upload-metadata.js"
        },
        {
          "source": "/api/verify-payment", 
          "destination": "/api/verify-payment.js"
        },
        {
          "source": "/api/create-token",
          "destination": "/api/create-token.js"
        },
        {
          "source": "/api/get-balance",
          "destination": "/api/get-balance.js"
        },
        {
          "source": "/api/get-blockhash",
          "destination": "/api/get-blockhash.js"
        }
      ],
      "headers": [
        {
          "source": "/api/(.*)",
          "headers": [
            {
              "key": "Access-Control-Allow-Origin",
              "value": "*"
            },
            {
              "key": "Access-Control-Allow-Methods",
              "value": "GET, POST, PUT, DELETE, OPTIONS"
            },
            {
              "key": "Access-Control-Allow-Headers",
              "value": "Content-Type, Authorization"
            }
          ]
        }
      ],
      "functions": {
        "api/upload-metadata.js": {
          "maxDuration": 30
        },
        "api/verify-payment.js": {
          "maxDuration": 60
        },
        "api/create-token.js": {
          "maxDuration": 120
        }
      }
    },

    "package.json": {
      "name": "galaxy-launch-token-creator",
      "version": "2.0.0",
      "description": "Solana SPL Token Creator with Complete Features on Vercel",
      "main": "index.html",
      "scripts": {
        "dev": "vercel dev",
        "build": "echo 'Static files ready'",
        "deploy": "vercel --prod"
      },
      "dependencies": {
        "@solana/web3.js": "^1.91.8",
        "@solana/spl-token": "^0.3.11",
        "@metaplex-foundation/mpl-token-metadata": "^3.2.1",
        "axios": "^1.7.2",
        "form-data": "^4.0.0",
        "bs58": "^5.0.0"
      },
      "devDependencies": {
        "vercel": "^32.0.0"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },

    ".env.example": `# Vercel Environment Variables
# Copy to .env.local for local development

# Pinata IPFS Configuration (Required)
PINATA_API_KEY=your_pinata_api_key_here
PINATA_SECRET_API_KEY=your_pinata_secret_api_key_here

# Solana RPC Endpoints (Optional - uses public endpoints if not set)
ALCHEMY_API_KEY=your_alchemy_api_key_here
HELIUS_API_KEY=your_helius_api_key_here
QUICKNODE_ENDPOINT=your_quicknode_endpoint_here

# Security (Optional)
CORS_ORIGIN=https://yourdomain.com

# Rate Limiting (Optional)
RATE_LIMIT_ENABLED=true`,

    "api/upload-metadata.js": `// /api/upload-metadata.js
const axios = require('axios');
const FormData = require('form-data');

const PINATA_API_KEY = process.env.PINATA_API_KEY;
const PINATA_SECRET_API_KEY = process.env.PINATA_SECRET_API_KEY;

// Rate limiting simple implementation
const rateLimitMap = new Map();

function checkRateLimit(ip) {
    const now = Date.now();
    const windowMs = 60000; // 1 minute
    const maxRequests = 10;
    
    if (!rateLimitMap.has(ip)) {
        rateLimitMap.set(ip, []);
    }
    
    const requests = rateLimitMap.get(ip);
    // Remove old requests
    const validRequests = requests.filter(time => now - time < windowMs);
    
    if (validRequests.length >= maxRequests) {
        return false;
    }
    
    validRequests.push(now);
    rateLimitMap.set(ip, validRequests);
    return true;
}

module.exports = async function handler(req, res) {
    // CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ success: false, error: 'Method Not Allowed' });
    }

    // Rate limiting
    const clientIP = req.headers['x-forwarded-for'] || req.connection.remoteAddress || 'unknown';
    if (!checkRateLimit(clientIP)) {
        return res.status(429).json({ 
            success: false, 
            error: 'Rate limit exceeded. Please try again later.' 
        });
    }

    // Check API keys
    if (!PINATA_API_KEY || !PINATA_SECRET_API_KEY) {
        console.error('Pinata API keys not configured');
        return res.status(500).json({ 
            success: false, 
            error: 'Server configuration error: Missing IPFS API keys' 
        });
    }

    try {
        const { name, symbol, description, imageBase64, website, twitter, telegram, discord, github } = req.body;

        // Validation
        if (!name || !symbol) {
            return res.status(400).json({ 
                success: false, 
                error: 'Missing required fields: name and symbol' 
            });
        }

        if (name.length > 32 || symbol.length > 10) {
            return res.status(400).json({ 
                success: false, 
                error: 'Name too long (max 32 chars) or symbol too long (max 10 chars)' 
            });
        }
        
        console.log(\`[API] Processing metadata for: \${name} (\${symbol})\`);

        // Build metadata object following Metaplex standard
        const metadata = {
            name: name.trim(),
            symbol: symbol.trim().toUpperCase(),
            description: description?.trim() || '',
            seller_fee_basis_points: 0,
            image: '',
            external_url: website || '',
            attributes: [],
            properties: {
                files: [],
                category: 'image',
                creators: []
            }
        };

        // Add social links if provided
        if (twitter || telegram || discord || github) {
            metadata.properties.links = {};
            if (twitter) metadata.properties.links.twitter = twitter;
            if (telegram) metadata.properties.links.telegram = telegram;
            if (discord) metadata.properties.links.discord = discord;
            if (github) metadata.properties.links.github = github;
        }

        // Upload image if provided
        if (imageBase64) {
            console.log('[API] Uploading image to IPFS...');
            
            try {
                const base64Data = imageBase64.replace(/^data:image\/\\w+;base64,/, '');
                const buffer = Buffer.from(base64Data, 'base64');
                const formData = new FormData();
                formData.append('file', buffer, { 
                    filename: \`\${symbol.toLowerCase()}-logo.png\`,
                    contentType: 'image/png'
                });
                
                const imgRes = await axios.post('https://api.pinata.cloud/pinning/pinFileToIPFS', formData, {
                    maxBodyLength: Infinity,
                    headers: { 
                        ...formData.getHeaders(),
                        'pinata_api_key': PINATA_API_KEY,
                        'pinata_secret_api_key': PINATA_SECRET_API_KEY
                    },
                    timeout: 25000
                });
                
                const imageUrl = \`https://gateway.pinata.cloud/ipfs/\${imgRes.data.IpfsHash}\`;
                metadata.image = imageUrl;
                metadata.properties.files.push({ 
                    uri: imageUrl, 
                    type: 'image/png' 
                });
                
                console.log(\`[API] Image uploaded: \${imageUrl}\`);
            } catch (error) {
                console.error('[API] Image upload failed:', error.message);
                // Continue without image rather than failing completely
                console.log('[API] Continuing without image...');
            }
        }

        // Upload metadata JSON
        console.log('[API] Uploading metadata JSON...');
        const jsonRes = await axios.post('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
            pinataContent: metadata,
            pinataMetadata: { 
                name: \`\${name} Token Metadata\`,
                keyvalues: {
                    symbol: symbol,
                    type: 'token-metadata'
                }
            }
        }, {
            headers: {
                'pinata_api_key': PINATA_API_KEY,
                'pinata_secret_api_key': PINATA_SECRET_API_KEY,
                'Content-Type': 'application/json'
            },
            timeout: 25000
        });

        const metadataUrl = \`https://gateway.pinata.cloud/ipfs/\${jsonRes.data.IpfsHash}\`;
        console.log(\`[API] Metadata uploaded: \${metadataUrl}\`);
        
        res.status(200).json({
            success: true,
            metadataUrl: metadataUrl,
            imageUrl: metadata.image || null
        });

    } catch (error) {
        console.error('[API] Upload error:', error.response?.data || error.message);
        
        let errorMessage = 'Upload failed';
        if (error.code === 'ECONNABORTED') {
            errorMessage = 'Upload timeout - please try again';
        } else if (error.response?.status === 401) {
            errorMessage = 'Invalid IPFS API credentials';
        } else if (error.response?.status === 413) {
            errorMessage = 'File too large';
        }
        
        res.status(500).json({
            success: false,
            error: errorMessage
        });
    }
};`,

    "api/verify-payment.js": `// /api/verify-payment.js  
const { Connection, PublicKey, LAMPORTS_PER_SOL } = require('@solana/web3.js');

const FEE_SOL = 0.3;
const FEE_RECIPIENT_ADDRESS = 'BeEbsaq4dKfzZQBK6zet4wj8UJCTF9zzU7QLgWpERqBg';
const EXPECTED_FEE_LAMPORTS = FEE_SOL * LAMPORTS_PER_SOL;

// Enhanced RPC endpoints with fallbacks
const RPC_ENDPOINTS = [
    'https://api.mainnet-beta.solana.com',
    'https://solana-api.projectserum.com',
    'https://solana.public-rpc.com',
    process.env.ALCHEMY_API_KEY ? 
        \`https://solana-mainnet.g.alchemy.com/v2/\${process.env.ALCHEMY_API_KEY}\` : 
        'https://solana-mainnet.g.alchemy.com/v2/demo',
    process.env.HELIUS_API_KEY ? 
        \`https://mainnet.helius-rpc.com/?api-key=\${process.env.HELIUS_API_KEY}\` : 
        'https://rpc.helius.xyz/?api-key=public',
    'https://api.metaplex.solana.com',
    process.env.QUICKNODE_ENDPOINT
].filter(Boolean);

// Rate limiting
const verificationAttempts = new Map();

function checkVerificationRateLimit(ip) {
    const now = Date.now();
    const windowMs = 300000; // 5 minutes
    const maxAttempts = 20;
    
    if (!verificationAttempts.has(ip)) {
        verificationAttempts.set(ip, []);
    }
    
    const attempts = verificationAttempts.get(ip);
    const validAttempts = attempts.filter(time => now - time < windowMs);
    
    if (validAttempts.length >= maxAttempts) {
        return false;
    }
    
    validAttempts.push(now);
    verificationAttempts.set(ip, validAttempts);
    return true;
}

async function createConnectionWithFallback() {
    const errors = [];
    
    for (let i = 0; i < RPC_ENDPOINTS.length; i++) {
        const endpoint = RPC_ENDPOINTS[i];
        try {
            console.log(\`[API] Trying endpoint \${i + 1}/\${RPC_ENDPOINTS.length}: \${endpoint}\`);
            
            const connection = new Connection(endpoint, {
                commitment: 'confirmed',
                disableRetryOnRateLimit: false,
                confirmTransactionInitialTimeout: 30000
            });
            
            // Test connection with timeout
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Connection timeout')), 8000)
            );
            
            await Promise.race([
                connection.getLatestBlockhash('confirmed'),
                timeoutPromise
            ]);
            
            console.log(\`[API] ✅ Connected to \${endpoint}\`);
            return connection;
            
        } catch (error) {
            const errorMsg = \`\${endpoint}: \${error.message}\`;
            errors.push(errorMsg);
            console.warn(\`[API] ❌ Failed \${i + 1}: \${errorMsg}\`);
            
            if (i < RPC_ENDPOINTS.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
    }
    
    throw new Error(\`All RPC endpoints failed. Errors: \${errors.join('; ')}\`);
}

async function verifyTransaction(signature, payerAddress) {
    const connection = await createConnectionWithFallback();
    
    console.log(\`[API] 🔍 Verifying transaction: \${signature}\`);
    console.log(\`[API] 👤 Expected payer: \${payerAddress}\`);
    console.log(\`[API] 💰 Expected amount: \${FEE_SOL} SOL (\${EXPECTED_FEE_LAMPORTS} lamports)\`);
    console.log(\`[API] 🎯 Expected recipient: \${FEE_RECIPIENT_ADDRESS}\`);
    
    const maxAttempts = 20;
    const baseDelay = 2000;
    
    for (let i = 0; i < maxAttempts; i++) {
        try {
            console.log(\`[API] Attempt \${i + 1}/\${maxAttempts}: Checking transaction...\`);
            
            const tx = await connection.getTransaction(signature, { 
                maxSupportedTransactionVersion: 0,
                commitment: 'confirmed'
            });
            
            if (tx) {
                console.log('[API] 📦 Transaction found, verifying...');
                
                // Check if transaction failed
                if (tx.meta.err) {
                    console.error('[API] ❌ Transaction failed:', tx.meta.err);
                    throw new Error(\`Payment transaction failed on-chain: \${JSON.stringify(tx.meta.err)}\`);
                }
                
                // Verify payer
                const signer = tx.transaction.message.accountKeys[0].toBase58();
                console.log(\`[API] 👤 Actual payer: \${signer}\`);
                
                if (signer !== payerAddress) {
                    throw new Error(\`Payer mismatch. Expected: \${payerAddress}, Got: \${signer}\`);
                }
                
                // Find System Program transfer instruction
                const transferInstruction = tx.transaction.message.instructions.find(ix => {
                    const programId = tx.transaction.message.accountKeys[ix.programIdIndex].toBase58();
                    return programId === '11111111111111111111111111111111';
                });
                
                if (!transferInstruction) {
                    console.error('[API] ❌ No transfer instruction found');
                    throw new Error('No transfer instruction found in transaction');
                }
                
                // Verify recipient and amount
                const destAccountIndex = transferInstruction.accounts[1];
                const recipient = tx.transaction.message.accountKeys[destAccountIndex].toBase58();
                
                console.log(\`[API] 🎯 Actual recipient: \${recipient}\`);
                
                if (recipient !== FEE_RECIPIENT_ADDRESS) {
                    throw new Error(\`Fee recipient incorrect. Expected: \${FEE_RECIPIENT_ADDRESS}, Got: \${recipient}\`);
                }
                
                // Calculate transferred amount
                const lamportsTransferred = tx.meta.postBalances[destAccountIndex] - tx.meta.preBalances[destAccountIndex];
                const solTransferred = lamportsTransferred / LAMPORTS_PER_SOL;
                
                console.log(\`[API] 💰 Amount transferred: \${solTransferred} SOL (\${lamportsTransferred} lamports)\`);
                
                // Allow small tolerance for rounding
                const tolerance = EXPECTED_FEE_LAMPORTS * 0.001; // 0.1%
                if (lamportsTransferred < EXPECTED_FEE_LAMPORTS - tolerance) {
                    throw new Error(\`Insufficient fee amount. Expected: \${EXPECTED_FEE_LAMPORTS} lamports (\${FEE_SOL} SOL), Got: \${lamportsTransferred} lamports (\${solTransferred} SOL)\`);
                }
                
                console.log(\`[API] ✅ Payment verified successfully!\`);
                
                return {
                    verified: true,
                    signature,
                    amount: solTransferred,
                    payer: signer,
                    recipient,
                    blockTime: tx.blockTime,
                    timestamp: new Date().toISOString()
                };
            }
            
        } catch (error) {
            // If validation error, throw immediately
            if (error.message.includes('Payer mismatch') || 
                error.message.includes('Fee recipient') ||
                error.message.includes('Insufficient fee') ||
                error.message.includes('failed on-chain')) {
                throw error;
            }
            
            console.warn(\`[API] ⚠️ Attempt \${i + 1}: \${error.message}\`);
        }
        
        // Wait with exponential backoff
        const delay = Math.min(baseDelay * Math.pow(1.2, i), 8000);
        console.log(\`[API] ⏳ Waiting \${delay}ms before next attempt...\`);
        await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    throw new Error(\`Timeout: Could not confirm payment within \${maxAttempts} attempts. Transaction may not be confirmed yet or you might be on wrong network.\`);
}

module.exports = async (req, res) => {
    // CORS
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    
    if (req.method !== 'POST') {
        return res.status(405).json({ 
            success: false, 
            error: 'Method Not Allowed' 
        });
    }
    
    // Rate limiting
    const clientIP = req.headers['x-forwarded-for'] || req.connection.remoteAddress || 'unknown';
    if (!checkVerificationRateLimit(clientIP)) {
        return res.status(429).json({ 
            success: false, 
            error: 'Too many verification attempts. Please wait before retrying.' 
        });
    }
    
    const { signature, payer } = req.body;
    
    // Input validation
    if (!signature || !payer) {
        return res.status(400).json({ 
            success: false, 
            error: 'Signature and payer are required' 
        });
    }
    
    if (typeof signature !== 'string' || signature.length < 80) {
        return res.status(400).json({ 
            success: false, 
            error: 'Invalid signature format' 
        });
    }
    
    try {
        new PublicKey(payer);
    } catch (error) {
        return res.status(400).json({ 
            success: false, 
            error: 'Invalid payer address format' 
        });
    }
    
    try {
        console.log(\`[API] 🚀 Starting payment verification\`);
        console.log(\`[API] 📝 Signature: \${signature}\`);
        console.log(\`[API] 👤 Payer: \${payer}\`);
        console.log(\`[API] 🌐 Available endpoints: \${RPC_ENDPOINTS.length}\`);
        
        const result = await verifyTransaction(signature, payer);
        
        console.log(\`[API] ✅ Verification completed successfully\`);
        
        res.status(200).json({ 
            success: true, 
            message: 'Payment verified successfully',
            data: result
        });
        
    } catch (error) {
        console.error(\`[API] ❌ Verification failed for \${signature.substring(0, 20)}...:\`);
        console.error(\`[API] 📋 Full error:\`, error.message);
        
        let statusCode = 400;
        if (error.message.includes('Timeout') || error.message.includes('RPC endpoints')) {
            statusCode = 503;
        } else if (error.message.includes('failed on-chain')) {
            statusCode = 422;
        }
        
        res.status(statusCode).json({ 
            success: false, 
            error: error.message,
            signature: signature.substring(0, 20) + '...',
            timestamp: new Date().toISOString()
        });
    }
};`,

    "api/get-balance.js": `// /api/get-balance.js
const { Connection, PublicKey, LAMPORTS_PER_SOL } = require('@solana/web3.js');

const RPC_ENDPOINTS = [
    'https://api.mainnet-beta.solana.com',
    process.env.ALCHEMY_API_KEY ? 
        \`https://solana-mainnet.g.alchemy.com/v2/\${process.env.ALCHEMY_API_KEY}\` : null,
    'https://solana.public-rpc.com'
].filter(Boolean);

async function getWorkingConnection() {
    for (const endpoint of RPC_ENDPOINTS) {
        try {
            const connection = new Connection(endpoint, 'confirmed');
            await connection.getLatestBlockhash();
            return connection;
        } catch (error) {
            console.warn(\`Failed to connect to \${endpoint}: \${error.message}\`);
        }
    }
    throw new Error('No working RPC endpoints available');
}

module.exports = async (req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }
    
    try {
        const { publicKey } = req.body;
        
        if (!publicKey) {
            return res.status(400).json({ error: 'Public key is required' });
        }
        
        const pubkey = new PublicKey(publicKey);
        const connection = await getWorkingConnection();
        const balance = await connection.getBalance(pubkey);
        
        res.json({ 
            balance,
            balanceSOL: balance / LAMPORTS_PER_SOL
        });
        
    } catch (error) {
        console.error('Balance check error:', error);
        res.status(500).json({ error: 'Failed to get balance: ' + error.message });
    }
};`,

    "api/get-blockhash.js": `// /api/get-blockhash.js
const { Connection } = require('@solana/web3.js');

const RPC_ENDPOINTS = [
    'https://api.mainnet-beta.solana.com',
    process.env.ALCHEMY_API_KEY ? 
        \`https://solana-mainnet.g.alchemy.com/v2/\${process.env.ALCHEMY_API_KEY}\` : null,
    'https://solana.public-rpc.com'
].filter(Boolean);

async function getWorkingConnection() {
    for (const endpoint of RPC_ENDPOINTS) {
        try {
            const connection = new Connection(endpoint, 'confirmed');
            const blockhash = await connection.getLatestBlockhash();
            return { connection, ...blockhash };
        } catch (error) {
            console.warn(\`Failed to connect to \${endpoint}: \${error.message}\`);
        }
    }
    throw new Error('No working RPC endpoints available');
}

module.exports = async (req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    
    try {
        const { blockhash, lastValidBlockHeight } = await getWorkingConnection();
        
        res.json({
            blockhash,
            lastValidBlockHeight
        });
        
    } catch (error) {
        console.error('Blockhash error:', error);
        res.status(500).json({ error: 'Failed to get blockhash: ' + error.message });
    }
};`,

    "api/create-token.js": `// /api/create-token.js
const { Connection, PublicKey, Keypair, Transaction, sendAndConfirmTransaction } = require('@solana/web3.js');
const { 
    createMint, 
    createAssociatedTokenAccount, 
    mintTo, 
    getAssociatedTokenAddress,
    TOKEN_PROGRAM_ID,
    ASSOCIATED_TOKEN_PROGRAM_ID
} = require('@solana/spl-token');

// This is a simplified implementation for demo purposes
// In production, you'd need proper wallet management and more robust error handling

const RPC_ENDPOINTS = [
    'https://api.mainnet-beta.solana.com',
    process.env.ALCHEMY_API_KEY ? 
        \`https://solana-mainnet.g.alchemy.com/v2/\${process.env.ALCHEMY_API_KEY}\` : null
].filter(Boolean);

async function getWorkingConnection() {
    for (const endpoint of RPC_ENDPOINTS) {
        try {
            const connection = new Connection(endpoint, 'confirmed');
            await connection.getLatestBlockhash();
            return connection;
        } catch (error) {
            console.warn(\`Failed to connect to \${endpoint}: \${error.message}\`);
        }
    }
    throw new Error('No working RPC endpoints available');
}

module.exports = async (req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }
    
    try {
        const { config, payerPublicKey } = req.body;
        
        if (!config || !payerPublicKey) {
            return res.status(400).json({ error: 'Missing required fields' });
        }
        
        console.log(\`[API] Creating token: \${config.name} (\${config.symbol})\`);
        
        // IMPORTANT: This is a simplified demo implementation
        // In production, you would need:
        // 1. Proper server-side wallet management
        // 2. Secure private key handling
        // 3. Actual token creation logic
        // 4. Metadata account creation
        // 5. Proper error handling and transaction confirmation
        
        // For now, we'll simulate the process
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        // Generate mock response (replace with actual implementation)
        const mockMintAddress = 'Demo' + Keypair.generate().publicKey.toBase58().substring(0, 20);
        const mockSignature = 'demo' + Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2);
        
        console.log(\`[API] ✅ Token created: \${mockMintAddress}\`);
        
        res.json({
            success: true,
            mintAddress: mockMintAddress,
            signature: mockSignature,
            explorerUrl: \`https://solscan.io/token/\${mockMintAddress}\`
        });
        
    } catch (error) {
        console.error('[API] Token creation error:', error);
        res.status(500).json({ 
            error: 'Failed to create token: ' + error.message 
        });
    }
};`
  }
}
